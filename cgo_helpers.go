// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 23 Sep 2016 15:58:43 MSK.
// By https://git.io/cgogen. DO NOT EDIT.

package glfw

/*
#cgo darwin LDFLAGS: -framework Cocoa -framework OpenGL -framework IOKit -framework CoreVideo -lglfw3
#cgo linux LDFLAGS: -lGL -lX11 -lXrandr -lXxf86vm -lXi -lXcursor -lm -lXinerama -ldl -lrt -lglfw3
#cgo windows LDFLAGS: -lopengl32 -lgdi32 -lglfw3
#cgo freebsd LDFLAGS: -lGL -lX11 -lXrandr -lXxf86vm -lXi -lXcursor -lm -lXinerama -lglfw3
#cgo darwin CFLAGS: -D_GLFW_COCOA -D_GLFW_USE_CHDIR -D_GLFW_USE_MENUBAR -D_GLFW_USE_RETINA -Wno-deprecated-declarations
#cgo linux,wayland CFLAGS: -D_GLFW_WAYLAND
#cgo linux,!wayland CFLAGS: -D_GLFW_X11
#cgo windows CFLAGS: -D_GLFW_WIN32
#cgo freebsd,wayland CFLAGS: -D_GLFW_WAYLAND -D_GLFW_HAS_DLOPEN
#cgo freebsd,!wayland CFLAGS: -D_GLFW_X11 -D_GLFW_HAS_GLXGETPROCADDRESSARB -D_GLFW_HAS_DLOPEN
#include "GLFW/glfw3.h"
#include "callbacks.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

func (x Glproc) PassRef() (ref *C.GLFWglproc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if glprocED6D6669Func == nil {
		glprocED6D6669Func = x
	}
	return (*C.GLFWglproc)(C.GLFWglproc_ed6d6669), nil
}

func (x Glproc) PassValue() (ref C.GLFWglproc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if glprocED6D6669Func == nil {
		glprocED6D6669Func = x
	}
	return (C.GLFWglproc)(C.GLFWglproc_ed6d6669), nil
}

//export glprocED6D6669
func glprocED6D6669() {
	if glprocED6D6669Func != nil {
		glprocED6D6669Func()
		return
	}
	panic("callback func has not been set (race?)")
}

var glprocED6D6669Func Glproc

func (x Vkproc) PassRef() (ref *C.GLFWvkproc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vkproc97C76B47Func == nil {
		vkproc97C76B47Func = x
	}
	return (*C.GLFWvkproc)(C.GLFWvkproc_97c76b47), nil
}

func (x Vkproc) PassValue() (ref C.GLFWvkproc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if vkproc97C76B47Func == nil {
		vkproc97C76B47Func = x
	}
	return (C.GLFWvkproc)(C.GLFWvkproc_97c76b47), nil
}

//export vkproc97C76B47
func vkproc97C76B47() {
	if vkproc97C76B47Func != nil {
		vkproc97C76B47Func()
		return
	}
	panic("callback func has not been set (race?)")
}

var vkproc97C76B47Func Vkproc

// Ref returns a reference to C object as it is.
func (x *Monitor) Ref() *C.GLFWmonitor {
	if x == nil {
		return nil
	}
	return (*C.GLFWmonitor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Monitor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewMonitorRef converts the C object reference into a raw struct reference without wrapping.
func NewMonitorRef(ref unsafe.Pointer) *Monitor {
	return (*Monitor)(ref)
}

// NewMonitor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewMonitor() *Monitor {
	return (*Monitor)(allocMonitorMemory(1))
}

// allocMonitorMemory allocates memory for type C.GLFWmonitor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMonitorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMonitorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMonitorValue = unsafe.Sizeof([1]C.GLFWmonitor{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Monitor) PassRef() *C.GLFWmonitor {
	if x == nil {
		x = (*Monitor)(allocMonitorMemory(1))
	}
	return (*C.GLFWmonitor)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Window) Ref() *C.GLFWwindow {
	if x == nil {
		return nil
	}
	return (*C.GLFWwindow)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Window) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewWindowRef converts the C object reference into a raw struct reference without wrapping.
func NewWindowRef(ref unsafe.Pointer) *Window {
	return (*Window)(ref)
}

// NewWindow allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewWindow() *Window {
	return (*Window)(allocWindowMemory(1))
}

// allocWindowMemory allocates memory for type C.GLFWwindow in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWindowMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWindowValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWindowValue = unsafe.Sizeof([1]C.GLFWwindow{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Window) PassRef() *C.GLFWwindow {
	if x == nil {
		x = (*Window)(allocWindowMemory(1))
	}
	return (*C.GLFWwindow)(unsafe.Pointer(x))
}

// Ref returns a reference to C object as it is.
func (x *Cursor) Ref() *C.GLFWcursor {
	if x == nil {
		return nil
	}
	return (*C.GLFWcursor)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *Cursor) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewCursorRef converts the C object reference into a raw struct reference without wrapping.
func NewCursorRef(ref unsafe.Pointer) *Cursor {
	return (*Cursor)(ref)
}

// NewCursor allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewCursor() *Cursor {
	return (*Cursor)(allocCursorMemory(1))
}

// allocCursorMemory allocates memory for type C.GLFWcursor in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCursorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCursorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCursorValue = unsafe.Sizeof([1]C.GLFWcursor{})

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *Cursor) PassRef() *C.GLFWcursor {
	if x == nil {
		x = (*Cursor)(allocCursorMemory(1))
	}
	return (*C.GLFWcursor)(unsafe.Pointer(x))
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}

type stringHeader struct {
	Data uintptr
	Len  int
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(unsafe.Pointer(h.Data)), C.int(h.Len))
}

func (x ErrorFunc) PassRef() (ref *C.GLFWerrorfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if errorFuncADB17582Func == nil {
		errorFuncADB17582Func = x
	}
	return (*C.GLFWerrorfun)(C.GLFWerrorfun_adb17582), nil
}

func (x ErrorFunc) PassValue() (ref C.GLFWerrorfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if errorFuncADB17582Func == nil {
		errorFuncADB17582Func = x
	}
	return (C.GLFWerrorfun)(C.GLFWerrorfun_adb17582), nil
}

//export errorFuncADB17582
func errorFuncADB17582(carg0 C.int, carg1 *C.char) {
	if errorFuncADB17582Func != nil {
		arg0adb17582 := (int32)(carg0)
		arg1adb17582 := packPCharString(carg1)
		errorFuncADB17582Func(arg0adb17582, arg1adb17582)
		return
	}
	panic("callback func has not been set (race?)")
}

var errorFuncADB17582Func ErrorFunc

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

func (x WindowposFunc) PassRef() (ref *C.GLFWwindowposfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowposFunc358CF663Func == nil {
		windowposFunc358CF663Func = x
	}
	return (*C.GLFWwindowposfun)(C.GLFWwindowposfun_358cf663), nil
}

func (x WindowposFunc) PassValue() (ref C.GLFWwindowposfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowposFunc358CF663Func == nil {
		windowposFunc358CF663Func = x
	}
	return (C.GLFWwindowposfun)(C.GLFWwindowposfun_358cf663), nil
}

//export windowposFunc358CF663
func windowposFunc358CF663(carg0 *C.GLFWwindow, carg1 C.int, carg2 C.int) {
	if windowposFunc358CF663Func != nil {
		var arg0358cf663 []Window
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&arg0358cf663))
		hxfc4425b.Data = uintptr(unsafe.Pointer(carg0))
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?

		arg1358cf663 := (int32)(carg1)
		arg2358cf663 := (int32)(carg2)
		windowposFunc358CF663Func(arg0358cf663, arg1358cf663, arg2358cf663)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowposFunc358CF663Func WindowposFunc

func (x WindowsizeFunc) PassRef() (ref *C.GLFWwindowsizefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowsizeFuncE3C4FD6AFunc == nil {
		windowsizeFuncE3C4FD6AFunc = x
	}
	return (*C.GLFWwindowsizefun)(C.GLFWwindowsizefun_e3c4fd6a), nil
}

func (x WindowsizeFunc) PassValue() (ref C.GLFWwindowsizefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowsizeFuncE3C4FD6AFunc == nil {
		windowsizeFuncE3C4FD6AFunc = x
	}
	return (C.GLFWwindowsizefun)(C.GLFWwindowsizefun_e3c4fd6a), nil
}

//export windowsizeFuncE3C4FD6A
func windowsizeFuncE3C4FD6A(carg0 *C.GLFWwindow, carg1 C.int, carg2 C.int) {
	if windowsizeFuncE3C4FD6AFunc != nil {
		var arg0e3c4fd6a []Window
		hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&arg0e3c4fd6a))
		hxf95e7c8.Data = uintptr(unsafe.Pointer(carg0))
		hxf95e7c8.Cap = 0x7fffffff
		// hxf95e7c8.Len = ?

		arg1e3c4fd6a := (int32)(carg1)
		arg2e3c4fd6a := (int32)(carg2)
		windowsizeFuncE3C4FD6AFunc(arg0e3c4fd6a, arg1e3c4fd6a, arg2e3c4fd6a)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowsizeFuncE3C4FD6AFunc WindowsizeFunc

func (x WindowcloseFunc) PassRef() (ref *C.GLFWwindowclosefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowcloseFuncE25779B2Func == nil {
		windowcloseFuncE25779B2Func = x
	}
	return (*C.GLFWwindowclosefun)(C.GLFWwindowclosefun_e25779b2), nil
}

func (x WindowcloseFunc) PassValue() (ref C.GLFWwindowclosefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowcloseFuncE25779B2Func == nil {
		windowcloseFuncE25779B2Func = x
	}
	return (C.GLFWwindowclosefun)(C.GLFWwindowclosefun_e25779b2), nil
}

//export windowcloseFuncE25779B2
func windowcloseFuncE25779B2(carg0 *C.GLFWwindow) {
	if windowcloseFuncE25779B2Func != nil {
		var arg0e25779b2 []Window
		hxff2234b := (*sliceHeader)(unsafe.Pointer(&arg0e25779b2))
		hxff2234b.Data = uintptr(unsafe.Pointer(carg0))
		hxff2234b.Cap = 0x7fffffff
		// hxff2234b.Len = ?

		windowcloseFuncE25779B2Func(arg0e25779b2)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowcloseFuncE25779B2Func WindowcloseFunc

func (x WindowrefreshFunc) PassRef() (ref *C.GLFWwindowrefreshfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowrefreshFunc9F26BEFCFunc == nil {
		windowrefreshFunc9F26BEFCFunc = x
	}
	return (*C.GLFWwindowrefreshfun)(C.GLFWwindowrefreshfun_9f26befc), nil
}

func (x WindowrefreshFunc) PassValue() (ref C.GLFWwindowrefreshfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowrefreshFunc9F26BEFCFunc == nil {
		windowrefreshFunc9F26BEFCFunc = x
	}
	return (C.GLFWwindowrefreshfun)(C.GLFWwindowrefreshfun_9f26befc), nil
}

//export windowrefreshFunc9F26BEFC
func windowrefreshFunc9F26BEFC(carg0 *C.GLFWwindow) {
	if windowrefreshFunc9F26BEFCFunc != nil {
		var arg09f26befc []Window
		hxff73280 := (*sliceHeader)(unsafe.Pointer(&arg09f26befc))
		hxff73280.Data = uintptr(unsafe.Pointer(carg0))
		hxff73280.Cap = 0x7fffffff
		// hxff73280.Len = ?

		windowrefreshFunc9F26BEFCFunc(arg09f26befc)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowrefreshFunc9F26BEFCFunc WindowrefreshFunc

func (x WindowfocusFunc) PassRef() (ref *C.GLFWwindowfocusfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowfocusFunc16AF50D3Func == nil {
		windowfocusFunc16AF50D3Func = x
	}
	return (*C.GLFWwindowfocusfun)(C.GLFWwindowfocusfun_16af50d3), nil
}

func (x WindowfocusFunc) PassValue() (ref C.GLFWwindowfocusfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowfocusFunc16AF50D3Func == nil {
		windowfocusFunc16AF50D3Func = x
	}
	return (C.GLFWwindowfocusfun)(C.GLFWwindowfocusfun_16af50d3), nil
}

//export windowfocusFunc16AF50D3
func windowfocusFunc16AF50D3(carg0 *C.GLFWwindow, carg1 C.int) {
	if windowfocusFunc16AF50D3Func != nil {
		var arg016af50d3 []Window
		hxfa9955c := (*sliceHeader)(unsafe.Pointer(&arg016af50d3))
		hxfa9955c.Data = uintptr(unsafe.Pointer(carg0))
		hxfa9955c.Cap = 0x7fffffff
		// hxfa9955c.Len = ?

		arg116af50d3 := (int32)(carg1)
		windowfocusFunc16AF50D3Func(arg016af50d3, arg116af50d3)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowfocusFunc16AF50D3Func WindowfocusFunc

func (x WindowiconifyFunc) PassRef() (ref *C.GLFWwindowiconifyfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowiconifyFuncBB24B88BFunc == nil {
		windowiconifyFuncBB24B88BFunc = x
	}
	return (*C.GLFWwindowiconifyfun)(C.GLFWwindowiconifyfun_bb24b88b), nil
}

func (x WindowiconifyFunc) PassValue() (ref C.GLFWwindowiconifyfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if windowiconifyFuncBB24B88BFunc == nil {
		windowiconifyFuncBB24B88BFunc = x
	}
	return (C.GLFWwindowiconifyfun)(C.GLFWwindowiconifyfun_bb24b88b), nil
}

//export windowiconifyFuncBB24B88B
func windowiconifyFuncBB24B88B(carg0 *C.GLFWwindow, carg1 C.int) {
	if windowiconifyFuncBB24B88BFunc != nil {
		var arg0bb24b88b []Window
		hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&arg0bb24b88b))
		hxfa3f05c.Data = uintptr(unsafe.Pointer(carg0))
		hxfa3f05c.Cap = 0x7fffffff
		// hxfa3f05c.Len = ?

		arg1bb24b88b := (int32)(carg1)
		windowiconifyFuncBB24B88BFunc(arg0bb24b88b, arg1bb24b88b)
		return
	}
	panic("callback func has not been set (race?)")
}

var windowiconifyFuncBB24B88BFunc WindowiconifyFunc

func (x FramebuffersizeFunc) PassRef() (ref *C.GLFWframebuffersizefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if framebuffersizeFuncAE059393Func == nil {
		framebuffersizeFuncAE059393Func = x
	}
	return (*C.GLFWframebuffersizefun)(C.GLFWframebuffersizefun_ae059393), nil
}

func (x FramebuffersizeFunc) PassValue() (ref C.GLFWframebuffersizefun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if framebuffersizeFuncAE059393Func == nil {
		framebuffersizeFuncAE059393Func = x
	}
	return (C.GLFWframebuffersizefun)(C.GLFWframebuffersizefun_ae059393), nil
}

//export framebuffersizeFuncAE059393
func framebuffersizeFuncAE059393(carg0 *C.GLFWwindow, carg1 C.int, carg2 C.int) {
	if framebuffersizeFuncAE059393Func != nil {
		var arg0ae059393 []Window
		hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&arg0ae059393))
		hxf0d18b7.Data = uintptr(unsafe.Pointer(carg0))
		hxf0d18b7.Cap = 0x7fffffff
		// hxf0d18b7.Len = ?

		arg1ae059393 := (int32)(carg1)
		arg2ae059393 := (int32)(carg2)
		framebuffersizeFuncAE059393Func(arg0ae059393, arg1ae059393, arg2ae059393)
		return
	}
	panic("callback func has not been set (race?)")
}

var framebuffersizeFuncAE059393Func FramebuffersizeFunc

func (x MousebuttonFunc) PassRef() (ref *C.GLFWmousebuttonfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mousebuttonFunc8E0AA0AFunc == nil {
		mousebuttonFunc8E0AA0AFunc = x
	}
	return (*C.GLFWmousebuttonfun)(C.GLFWmousebuttonfun_8e0aa0a), nil
}

func (x MousebuttonFunc) PassValue() (ref C.GLFWmousebuttonfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if mousebuttonFunc8E0AA0AFunc == nil {
		mousebuttonFunc8E0AA0AFunc = x
	}
	return (C.GLFWmousebuttonfun)(C.GLFWmousebuttonfun_8e0aa0a), nil
}

//export mousebuttonFunc8E0AA0A
func mousebuttonFunc8E0AA0A(carg0 *C.GLFWwindow, carg1 C.int, carg2 C.int, carg3 C.int) {
	if mousebuttonFunc8E0AA0AFunc != nil {
		var arg08e0aa0a []Window
		hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&arg08e0aa0a))
		hxf2fab0d.Data = uintptr(unsafe.Pointer(carg0))
		hxf2fab0d.Cap = 0x7fffffff
		// hxf2fab0d.Len = ?

		arg18e0aa0a := (int32)(carg1)
		arg28e0aa0a := (int32)(carg2)
		arg38e0aa0a := (int32)(carg3)
		mousebuttonFunc8E0AA0AFunc(arg08e0aa0a, arg18e0aa0a, arg28e0aa0a, arg38e0aa0a)
		return
	}
	panic("callback func has not been set (race?)")
}

var mousebuttonFunc8E0AA0AFunc MousebuttonFunc

func (x CursorposFunc) PassRef() (ref *C.GLFWcursorposfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cursorposFunc39751795Func == nil {
		cursorposFunc39751795Func = x
	}
	return (*C.GLFWcursorposfun)(C.GLFWcursorposfun_39751795), nil
}

func (x CursorposFunc) PassValue() (ref C.GLFWcursorposfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cursorposFunc39751795Func == nil {
		cursorposFunc39751795Func = x
	}
	return (C.GLFWcursorposfun)(C.GLFWcursorposfun_39751795), nil
}

//export cursorposFunc39751795
func cursorposFunc39751795(carg0 *C.GLFWwindow, carg1 C.double, carg2 C.double) {
	if cursorposFunc39751795Func != nil {
		var arg039751795 []Window
		hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&arg039751795))
		hxf69fe70.Data = uintptr(unsafe.Pointer(carg0))
		hxf69fe70.Cap = 0x7fffffff
		// hxf69fe70.Len = ?

		arg139751795 := (float64)(carg1)
		arg239751795 := (float64)(carg2)
		cursorposFunc39751795Func(arg039751795, arg139751795, arg239751795)
		return
	}
	panic("callback func has not been set (race?)")
}

var cursorposFunc39751795Func CursorposFunc

func (x CursorenterFunc) PassRef() (ref *C.GLFWcursorenterfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cursorenterFunc6D33066CFunc == nil {
		cursorenterFunc6D33066CFunc = x
	}
	return (*C.GLFWcursorenterfun)(C.GLFWcursorenterfun_6d33066c), nil
}

func (x CursorenterFunc) PassValue() (ref C.GLFWcursorenterfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if cursorenterFunc6D33066CFunc == nil {
		cursorenterFunc6D33066CFunc = x
	}
	return (C.GLFWcursorenterfun)(C.GLFWcursorenterfun_6d33066c), nil
}

//export cursorenterFunc6D33066C
func cursorenterFunc6D33066C(carg0 *C.GLFWwindow, carg1 C.int) {
	if cursorenterFunc6D33066CFunc != nil {
		var arg06d33066c []Window
		hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&arg06d33066c))
		hxf65bf54.Data = uintptr(unsafe.Pointer(carg0))
		hxf65bf54.Cap = 0x7fffffff
		// hxf65bf54.Len = ?

		arg16d33066c := (int32)(carg1)
		cursorenterFunc6D33066CFunc(arg06d33066c, arg16d33066c)
		return
	}
	panic("callback func has not been set (race?)")
}

var cursorenterFunc6D33066CFunc CursorenterFunc

func (x ScrollFunc) PassRef() (ref *C.GLFWscrollfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if scrollFunc13E3E5D1Func == nil {
		scrollFunc13E3E5D1Func = x
	}
	return (*C.GLFWscrollfun)(C.GLFWscrollfun_13e3e5d1), nil
}

func (x ScrollFunc) PassValue() (ref C.GLFWscrollfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if scrollFunc13E3E5D1Func == nil {
		scrollFunc13E3E5D1Func = x
	}
	return (C.GLFWscrollfun)(C.GLFWscrollfun_13e3e5d1), nil
}

//export scrollFunc13E3E5D1
func scrollFunc13E3E5D1(carg0 *C.GLFWwindow, carg1 C.double, carg2 C.double) {
	if scrollFunc13E3E5D1Func != nil {
		var arg013e3e5d1 []Window
		hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&arg013e3e5d1))
		hxf3b8dbd.Data = uintptr(unsafe.Pointer(carg0))
		hxf3b8dbd.Cap = 0x7fffffff
		// hxf3b8dbd.Len = ?

		arg113e3e5d1 := (float64)(carg1)
		arg213e3e5d1 := (float64)(carg2)
		scrollFunc13E3E5D1Func(arg013e3e5d1, arg113e3e5d1, arg213e3e5d1)
		return
	}
	panic("callback func has not been set (race?)")
}

var scrollFunc13E3E5D1Func ScrollFunc

func (x KeyFunc) PassRef() (ref *C.GLFWkeyfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if keyFunc3F040623Func == nil {
		keyFunc3F040623Func = x
	}
	return (*C.GLFWkeyfun)(C.GLFWkeyfun_3f040623), nil
}

func (x KeyFunc) PassValue() (ref C.GLFWkeyfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if keyFunc3F040623Func == nil {
		keyFunc3F040623Func = x
	}
	return (C.GLFWkeyfun)(C.GLFWkeyfun_3f040623), nil
}

//export keyFunc3F040623
func keyFunc3F040623(carg0 *C.GLFWwindow, carg1 C.int, carg2 C.int, carg3 C.int, carg4 C.int) {
	if keyFunc3F040623Func != nil {
		var arg03f040623 []Window
		hxf7a6dff := (*sliceHeader)(unsafe.Pointer(&arg03f040623))
		hxf7a6dff.Data = uintptr(unsafe.Pointer(carg0))
		hxf7a6dff.Cap = 0x7fffffff
		// hxf7a6dff.Len = ?

		arg13f040623 := (int32)(carg1)
		arg23f040623 := (int32)(carg2)
		arg33f040623 := (int32)(carg3)
		arg43f040623 := (int32)(carg4)
		keyFunc3F040623Func(arg03f040623, arg13f040623, arg23f040623, arg33f040623, arg43f040623)
		return
	}
	panic("callback func has not been set (race?)")
}

var keyFunc3F040623Func KeyFunc

func (x CharFunc) PassRef() (ref *C.GLFWcharfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if charFunc6D9C4127Func == nil {
		charFunc6D9C4127Func = x
	}
	return (*C.GLFWcharfun)(C.GLFWcharfun_6d9c4127), nil
}

func (x CharFunc) PassValue() (ref C.GLFWcharfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if charFunc6D9C4127Func == nil {
		charFunc6D9C4127Func = x
	}
	return (C.GLFWcharfun)(C.GLFWcharfun_6d9c4127), nil
}

//export charFunc6D9C4127
func charFunc6D9C4127(carg0 *C.GLFWwindow, carg1 C.uint) {
	if charFunc6D9C4127Func != nil {
		var arg06d9c4127 []Window
		hxfe48d67 := (*sliceHeader)(unsafe.Pointer(&arg06d9c4127))
		hxfe48d67.Data = uintptr(unsafe.Pointer(carg0))
		hxfe48d67.Cap = 0x7fffffff
		// hxfe48d67.Len = ?

		arg16d9c4127 := (uint32)(carg1)
		charFunc6D9C4127Func(arg06d9c4127, arg16d9c4127)
		return
	}
	panic("callback func has not been set (race?)")
}

var charFunc6D9C4127Func CharFunc

func (x CharmodsFunc) PassRef() (ref *C.GLFWcharmodsfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if charmodsFuncA4666335Func == nil {
		charmodsFuncA4666335Func = x
	}
	return (*C.GLFWcharmodsfun)(C.GLFWcharmodsfun_a4666335), nil
}

func (x CharmodsFunc) PassValue() (ref C.GLFWcharmodsfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if charmodsFuncA4666335Func == nil {
		charmodsFuncA4666335Func = x
	}
	return (C.GLFWcharmodsfun)(C.GLFWcharmodsfun_a4666335), nil
}

//export charmodsFuncA4666335
func charmodsFuncA4666335(carg0 *C.GLFWwindow, carg1 C.uint, carg2 C.int) {
	if charmodsFuncA4666335Func != nil {
		var arg0a4666335 []Window
		hxf4171bf := (*sliceHeader)(unsafe.Pointer(&arg0a4666335))
		hxf4171bf.Data = uintptr(unsafe.Pointer(carg0))
		hxf4171bf.Cap = 0x7fffffff
		// hxf4171bf.Len = ?

		arg1a4666335 := (uint32)(carg1)
		arg2a4666335 := (int32)(carg2)
		charmodsFuncA4666335Func(arg0a4666335, arg1a4666335, arg2a4666335)
		return
	}
	panic("callback func has not been set (race?)")
}

var charmodsFuncA4666335Func CharmodsFunc

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

func (x DropFunc) PassRef() (ref *C.GLFWdropfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dropFunc1F4F28BEFunc == nil {
		dropFunc1F4F28BEFunc = x
	}
	return (*C.GLFWdropfun)(C.GLFWdropfun_1f4f28be), nil
}

func (x DropFunc) PassValue() (ref C.GLFWdropfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if dropFunc1F4F28BEFunc == nil {
		dropFunc1F4F28BEFunc = x
	}
	return (C.GLFWdropfun)(C.GLFWdropfun_1f4f28be), nil
}

//export dropFunc1F4F28BE
func dropFunc1F4F28BE(carg0 *C.GLFWwindow, carg1 C.int, carg2 **C.char) {
	if dropFunc1F4F28BEFunc != nil {
		var arg01f4f28be []Window
		hxf058b18 := (*sliceHeader)(unsafe.Pointer(&arg01f4f28be))
		hxf058b18.Data = uintptr(unsafe.Pointer(carg0))
		hxf058b18.Cap = 0x7fffffff
		// hxf058b18.Len = ?

		arg11f4f28be := (int32)(carg1)
		var arg21f4f28be []string
		packSString(arg21f4f28be, carg2)
		dropFunc1F4F28BEFunc(arg01f4f28be, arg11f4f28be, arg21f4f28be)
		return
	}
	panic("callback func has not been set (race?)")
}

var dropFunc1F4F28BEFunc DropFunc

func (x MonitorFunc) PassRef() (ref *C.GLFWmonitorfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if monitorFuncDE501D39Func == nil {
		monitorFuncDE501D39Func = x
	}
	return (*C.GLFWmonitorfun)(C.GLFWmonitorfun_de501d39), nil
}

func (x MonitorFunc) PassValue() (ref C.GLFWmonitorfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if monitorFuncDE501D39Func == nil {
		monitorFuncDE501D39Func = x
	}
	return (C.GLFWmonitorfun)(C.GLFWmonitorfun_de501d39), nil
}

//export monitorFuncDE501D39
func monitorFuncDE501D39(carg0 *C.GLFWmonitor, carg1 C.int) {
	if monitorFuncDE501D39Func != nil {
		var arg0de501d39 []Monitor
		hxff6bc57 := (*sliceHeader)(unsafe.Pointer(&arg0de501d39))
		hxff6bc57.Data = uintptr(unsafe.Pointer(carg0))
		hxff6bc57.Cap = 0x7fffffff
		// hxff6bc57.Len = ?

		arg1de501d39 := (int32)(carg1)
		monitorFuncDE501D39Func(arg0de501d39, arg1de501d39)
		return
	}
	panic("callback func has not been set (race?)")
}

var monitorFuncDE501D39Func MonitorFunc

func (x JoystickFunc) PassRef() (ref *C.GLFWjoystickfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if joystickFuncE5D73F5EFunc == nil {
		joystickFuncE5D73F5EFunc = x
	}
	return (*C.GLFWjoystickfun)(C.GLFWjoystickfun_e5d73f5e), nil
}

func (x JoystickFunc) PassValue() (ref C.GLFWjoystickfun, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if joystickFuncE5D73F5EFunc == nil {
		joystickFuncE5D73F5EFunc = x
	}
	return (C.GLFWjoystickfun)(C.GLFWjoystickfun_e5d73f5e), nil
}

//export joystickFuncE5D73F5E
func joystickFuncE5D73F5E(carg0 C.int, carg1 C.int) {
	if joystickFuncE5D73F5EFunc != nil {
		arg0e5d73f5e := (int32)(carg0)
		arg1e5d73f5e := (int32)(carg1)
		joystickFuncE5D73F5EFunc(arg0e5d73f5e, arg1e5d73f5e)
		return
	}
	panic("callback func has not been set (race?)")
}

var joystickFuncE5D73F5EFunc JoystickFunc

// allocVidmodeMemory allocates memory for type C.GLFWvidmode in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVidmodeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVidmodeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVidmodeValue = unsafe.Sizeof([1]C.GLFWvidmode{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vidmode) Ref() *C.GLFWvidmode {
	if x == nil {
		return nil
	}
	return x.ref98662845
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vidmode) Free() {
	if x != nil && x.allocs98662845 != nil {
		x.allocs98662845.(*cgoAllocMap).Free()
		x.ref98662845 = nil
	}
}

// NewVidmodeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVidmodeRef(ref unsafe.Pointer) *Vidmode {
	if ref == nil {
		return nil
	}
	obj := new(Vidmode)
	obj.ref98662845 = (*C.GLFWvidmode)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vidmode) PassRef() (*C.GLFWvidmode, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref98662845 != nil {
		return x.ref98662845, nil
	}
	mem98662845 := allocVidmodeMemory(1)
	ref98662845 := (*C.GLFWvidmode)(mem98662845)
	allocs98662845 := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	ref98662845.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs98662845.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref98662845.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs98662845.Borrow(cheight_allocs)

	var credBits_allocs *cgoAllocMap
	ref98662845.redBits, credBits_allocs = (C.int)(x.RedBits), cgoAllocsUnknown
	allocs98662845.Borrow(credBits_allocs)

	var cgreenBits_allocs *cgoAllocMap
	ref98662845.greenBits, cgreenBits_allocs = (C.int)(x.GreenBits), cgoAllocsUnknown
	allocs98662845.Borrow(cgreenBits_allocs)

	var cblueBits_allocs *cgoAllocMap
	ref98662845.blueBits, cblueBits_allocs = (C.int)(x.BlueBits), cgoAllocsUnknown
	allocs98662845.Borrow(cblueBits_allocs)

	var crefreshRate_allocs *cgoAllocMap
	ref98662845.refreshRate, crefreshRate_allocs = (C.int)(x.RefreshRate), cgoAllocsUnknown
	allocs98662845.Borrow(crefreshRate_allocs)

	x.ref98662845 = ref98662845
	x.allocs98662845 = allocs98662845
	return ref98662845, allocs98662845

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vidmode) PassValue() (C.GLFWvidmode, *cgoAllocMap) {
	if x.ref98662845 != nil {
		return *x.ref98662845, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Vidmode) Deref() {
	if x.ref98662845 == nil {
		return
	}
	x.Width = (int32)(x.ref98662845.width)
	x.Height = (int32)(x.ref98662845.height)
	x.RedBits = (int32)(x.ref98662845.redBits)
	x.GreenBits = (int32)(x.ref98662845.greenBits)
	x.BlueBits = (int32)(x.ref98662845.blueBits)
	x.RefreshRate = (int32)(x.ref98662845.refreshRate)
}

// allocGammarampMemory allocates memory for type C.GLFWgammaramp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGammarampMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGammarampValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGammarampValue = unsafe.Sizeof([1]C.GLFWgammaramp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Gammaramp) Ref() *C.GLFWgammaramp {
	if x == nil {
		return nil
	}
	return x.ref49b9eb5f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Gammaramp) Free() {
	if x != nil && x.allocs49b9eb5f != nil {
		x.allocs49b9eb5f.(*cgoAllocMap).Free()
		x.ref49b9eb5f = nil
	}
}

// NewGammarampRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGammarampRef(ref unsafe.Pointer) *Gammaramp {
	if ref == nil {
		return nil
	}
	obj := new(Gammaramp)
	obj.ref49b9eb5f = (*C.GLFWgammaramp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Gammaramp) PassRef() (*C.GLFWgammaramp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref49b9eb5f != nil {
		return x.ref49b9eb5f, nil
	}
	mem49b9eb5f := allocGammarampMemory(1)
	ref49b9eb5f := (*C.GLFWgammaramp)(mem49b9eb5f)
	allocs49b9eb5f := new(cgoAllocMap)
	var cred_allocs *cgoAllocMap
	ref49b9eb5f.red, cred_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Red)).Data)), cgoAllocsUnknown
	allocs49b9eb5f.Borrow(cred_allocs)

	var cgreen_allocs *cgoAllocMap
	ref49b9eb5f.green, cgreen_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Green)).Data)), cgoAllocsUnknown
	allocs49b9eb5f.Borrow(cgreen_allocs)

	var cblue_allocs *cgoAllocMap
	ref49b9eb5f.blue, cblue_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Blue)).Data)), cgoAllocsUnknown
	allocs49b9eb5f.Borrow(cblue_allocs)

	var csize_allocs *cgoAllocMap
	ref49b9eb5f.size, csize_allocs = (C.uint)(x.Size), cgoAllocsUnknown
	allocs49b9eb5f.Borrow(csize_allocs)

	x.ref49b9eb5f = ref49b9eb5f
	x.allocs49b9eb5f = allocs49b9eb5f
	return ref49b9eb5f, allocs49b9eb5f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Gammaramp) PassValue() (C.GLFWgammaramp, *cgoAllocMap) {
	if x.ref49b9eb5f != nil {
		return *x.ref49b9eb5f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Gammaramp) Deref() {
	if x.ref49b9eb5f == nil {
		return
	}
	hxf5fa529 := (*sliceHeader)(unsafe.Pointer(&x.Red))
	hxf5fa529.Data = uintptr(unsafe.Pointer(x.ref49b9eb5f.red))
	hxf5fa529.Cap = 0x7fffffff
	// hxf5fa529.Len = ?

	hxf21690b := (*sliceHeader)(unsafe.Pointer(&x.Green))
	hxf21690b.Data = uintptr(unsafe.Pointer(x.ref49b9eb5f.green))
	hxf21690b.Cap = 0x7fffffff
	// hxf21690b.Len = ?

	hxf1231c9 := (*sliceHeader)(unsafe.Pointer(&x.Blue))
	hxf1231c9.Data = uintptr(unsafe.Pointer(x.ref49b9eb5f.blue))
	hxf1231c9.Cap = 0x7fffffff
	// hxf1231c9.Len = ?

	x.Size = (uint32)(x.ref49b9eb5f.size)
}

// allocImageMemory allocates memory for type C.GLFWimage in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.GLFWimage{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.GLFWimage {
	if x == nil {
		return nil
	}
	return x.ref1787268c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) Free() {
	if x != nil && x.allocs1787268c != nil {
		x.allocs1787268c.(*cgoAllocMap).Free()
		x.ref1787268c = nil
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref1787268c = (*C.GLFWimage)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.GLFWimage, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1787268c != nil {
		return x.ref1787268c, nil
	}
	mem1787268c := allocImageMemory(1)
	ref1787268c := (*C.GLFWimage)(mem1787268c)
	allocs1787268c := new(cgoAllocMap)
	var cwidth_allocs *cgoAllocMap
	ref1787268c.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs1787268c.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref1787268c.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs1787268c.Borrow(cheight_allocs)

	var cpixels_allocs *cgoAllocMap
	ref1787268c.pixels, cpixels_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Pixels)).Data)), cgoAllocsUnknown
	allocs1787268c.Borrow(cpixels_allocs)

	x.ref1787268c = ref1787268c
	x.allocs1787268c = allocs1787268c
	return ref1787268c, allocs1787268c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.GLFWimage, *cgoAllocMap) {
	if x.ref1787268c != nil {
		return *x.ref1787268c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Image) Deref() {
	if x.ref1787268c == nil {
		return
	}
	x.Width = (int32)(x.ref1787268c.width)
	x.Height = (int32)(x.ref1787268c.height)
	hxf04b15b := (*sliceHeader)(unsafe.Pointer(&x.Pixels))
	hxf04b15b.Data = uintptr(unsafe.Pointer(x.ref1787268c.pixels))
	hxf04b15b.Cap = 0x7fffffff
	// hxf04b15b.Len = ?

}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

// packPUcharString creates a Go string backed by *C.uchar and avoids copying.
func packPUcharString(p *C.uchar) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = uintptr(unsafe.Pointer(p))
		for *p != 0 {
			p = (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - h.Data)
	}
	return
}
